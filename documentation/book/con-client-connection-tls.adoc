[id='client-connection-tls-{context}']
= Kafka Client connections through TLS

Encrypted communication between Kafka brokers and clients is provided through the `CLIENTTLS` listener on port 9093.

NOTE: You can use the `CLIENTTLS` listener on port 9092 for unencrypted communication with brokers.

If a Kafka client wants to connect to the encrypted listener (`CLIENTTLS`) on port 9093, it needs to trust the cluster CA certificate in order to verify the broker certificate received during the SSL/TLS handshake.
The cluster CA certificate can be extracted from the generated `_cluster-name_-cluster-ca-cert` `Secret`.

ifdef::Kubernetes[]
On {KubernetesName}, the certificate can be extracted with the following command:

[source,shell]
kubectl get secret <cluster-name>-cluster-ca-cert -o jsonpath='{.data.ca\.crt}' | base64 -d > ca.crt

endif::Kubernetes[]

On {OpenShiftName}, the certificate can be extracted with the following command:

[source,shell]
oc get secret <cluster-name>-cluster-ca-cert -o jsonpath='{.data.ca\.crt}' | base64 -d > ca.crt

The Kafka client has to be configured to trust certificates signed by this CA.
For the Java-based Kafka Producer, Consumer and Streams APIs, you can do this by importing the CA certificate into the JVM's truststore using the following keytool command:

[source,shell]
keytool -keystore client.truststore.jks -alias CARoot -import -file ca.crt

Lastly, specify the following properties to configure the Kafka client:

* `security.protocol`: SSL is the value for using encryption.
* `ssl.truststore.location`: the truststore location where the certificates were imported.
* `ssl.truststore.password`: password for accessing the truststore. This property can be omitted if it is not needed by the truststore.

The current implementation does not support Subject Alternative Names (SAN) so the hostname verification should be disabled on the client side.
For doing so the `ssl.endpoint.identification.algorithm` property needs to be set as empty.
