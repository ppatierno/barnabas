// Module included in the following module:
//
// con-oauth-config.adoc

[id='proc-oauth-authentication-broker-config-{context}']
= Configuring OAuth 2.0 support for Kafka brokers

This procedure describes how to configure Kafka brokers so that the broker listeners are enabled to use OAuth 2.0 authentication using an authorization server.

We advise use of OAuth 2.0 over an encrypted interface through configuration of TLS listeners.
Plain listeners are not recommended.

If the authorization server is using certificates signed by the trusted CA and matching the OAuth 2.0 server hostname, TLS connection works using the default settings.
Otherwise, you have two connection options for your listener configuration when delegating token validation to the authorization server:

* xref:example-1[Configuring fast local JWT token validation]
* xref:example-2[Configuring token validation using an introspection endpoint]

.Before you start

For more information on the configuration of OAuth 2.0 authentication for Kafka broker listeners, see:

* xref:appendix_crds#type-KafkaListenerAuthenticationOAuth-reference[KafkaListenerAuthenticationOAuth schema reference]
* xref:assembly-configuring-kafka-broker-listeners-deployment-configuration-kafka[Kafka broker listeners]
* xref:assembly-kafka-authentication-and-authorization-deployment-configuration-kafka[Authentication and Authorization]

.Prerequisites

* Strimzi and Kafka are running
* An OAuth 2.0 authorization server is deployed

.Procedure

. Update the Kafka broker configuration (`Kafka.spec.kafka`) of your `Kafka` resource in an editor.
+
[source,shell]
----
kubectl edit kafka my-cluster
----

. Configure the Kafka broker `listeners` configuration.
+
The configuration for each type of listener does not have to be the same, as they are independent.
+
The examples here show the configuration options as configured for external listeners.
+
--
[[example-1]]
.Example 1: Configuring fast local JWT token validation
[source,yaml,subs="+quotes,attributes"]
----
external:
  type: loadbalancer
  authentication:
    type: oauth <1>
    validIssuerUri: <__https://<auth-server-address>/auth/realms/external__> <2>
    jwksEndpointUri: <__https://<auth-server-address>/auth/realms/external/protocol/openid-connect/certs__> <3>
    userNameClaim: preferred_username <4>
    tlsTrustedCertificates: <5>
    - secretName: oauth-server-cert
      certificate: ca.crt
    disableTlsHostnameVerification: true <6>
    jwksExpirySeconds: 360 <7>
    jwksRefreshSeconds: 300 <8>
    enableECDSA: "true" <9>
----
<1> Listener type set to `oauth`.
<2> URI of the token issuer used for authentication.
<3> URI of the JWKS certificate endpoint used for local JWT validation.
<4> The token claim (or key) that contains the actual user name in the token. The user name is the _principal_ used to identify the user. The `userNameClaim` value will depend on the authentication flow and the authorization server used.
<5> (Optional) Trusted certificates for TLS connection to the authorization server.
<6> (Optional) Disable TLS hostname verification. Default is `false`.
<7> The duration the JWKs certificates are considered valid before they expire. Default is `360` seconds. If you specify a longer time, consider the risk of allowing access to revoked certificates.
<8> The period between refreshes of JWKs certificates. The interval must be at least 60 seconds shorter than the expiry interval. Default is `300` seconds.
<9> (Optional) If ECDSA is used for signing JWT tokens on authorization server, then this needs to be enabled. It installs additional crypto providers using BouncyCastle crypto library. Default is `false`.

[[example-2]]
.Example 2: Configuring token validation using an introspection endpoint
[source,yaml,subs="+quotes,attributes"]
----
external:
  type: loadbalancer
  authentication:
    type: oauth
    validIssuerUri: <__https://<auth-server-address>/auth/realms/external__>
    introspectionEndpointUri: <__https://<auth-server-address>/auth/realms/external/protocol/openid-connect/token/introspect__> <1>
    clientId: kafka-broker <2>
    clientSecret: <3>
      secretName: my-cluster-oauth
      key: clientSecret
    userNameClaim: preferred_username <4>
----
--
<1> URI of the token introspection endpoint.
<2> Client ID to identify the client.
<3> Client Secret and client ID is used for authentication.
<4> The token claim (or key) that contains the actual user name in the token. The user name is the _principal_ used to identify the user. The `userNameClaim` value will depend on the authorization server used.
+
Depending on how you apply OAuth 2.0 authentication, and the type of authorization server, there are additional (optional) configuration settings you can use:
+
[source,yaml,subs="+quotes,attributes"]
----
  # ...
  authentication:
    type: oauth
    # ...
    checkIssuer: false <1>
    fallbackUserNameClaim: client_id <2>
    fallbackUserNamePrefix: client-account- <3>
    validTokenType: bearer <4>
    userInfoEndpointUri: <__https://<auth-server-address>/auth/realms/external/protocol/openid-connect/userinfo__> <5>
----
<1> If your authorization server does not provide an `iss` claim, it is not possible to perform an issuer check. In this situation, set `checkIssuer` to `false` and do not specify a `validIssuerUri`. Default is `true`.
<2> An authorization server may not provide a single attribute to identify both regular users and clients. A client authenticating in its own name might provide a `client_id`. But a user authenticating using a username and password, to obtain a refresh token or an access token, might provide a `username` attribute in addition to a `client_id`. Use this fallback option to specify the username claim (attribute) to use if a primary user id attribute is not available.
<3> In situations where `fallbackUserNameClaim` is applicable, it may also be necessary to prevent name collisions between the values of the username claim, and those of the fallback username claim. Consider a situation where a client called `producer` exists, but also a regular user called `producer` exists. In order to differentiate between the two, you can use this property to add a prefix to the user id of the client.
<4> (Only applicable when using `introspectionEndpointUri`) Depending on the authorization server you are using, the Introspection Endpoint may or may not return the `token_type` attribute., or it may contain different values. You can specify a valid token type value that the response from the Introspection Endpoint has to contain.
<5> (Only applicable when using `introspectionEndpointUri`) The authorization server may be configured or implemented in such a way to not provide any identifiable information in an Introspection Endpoint response. In order to obtain the user id, you can configure the URI of the User Info Endpoint as a fallback. The `userNameClaim`, `fallbackUserNameClaim`, and `fallbackUserNamePrefix` settings are applied to the response of User Info Endpoint.

. Save and exit the editor, then wait for rolling updates to complete.

. Check the update in the logs or by watching the pod state transitions:
+
[source,shell,subs="+quotes,attributes"]
----
kubectl logs -f ${POD_NAME} -c ${CONTAINER_NAME}
kubectl get po -w
----
+
The rolling update configures the brokers to use OAuth 2.0 authentication.

.What to do next

* xref:proc-oauth-client-config-{context}[Configure your Kafka clients to use OAuth 2.0]
