// Module included in the following module:
//
// con-oauth-authorization-keycloak-authorization-services.adoc

[id='con-oauth-authorization-keycloak-example_{context}']
= Example authorization rules configuration using Authorization Services

This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.
The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.
We deploy the Kafka cluster configured to use one of the pre-configured realms.
We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.
We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.


== Token Based Authorization with Keycloak Authorization Services

Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.
For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.

When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.
The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.
Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.


== Starting Up the Pods

NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes

For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes

NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master

[source,yaml]
----
export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples
----

.Deploy the Postgres database for Keycloak

[source,yaml]
----
kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml
kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml
----

.Deploy the Keycloak server

[source,yaml]
----
kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml
kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml
----

If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:

[source,yaml]
----
curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e "s#myproject#default#" | kubectl apply -f -
----

.Deploy the minimal Kafka cluster

Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.

[source,yaml]
----
kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml
----


== Using the Keycloak Admin Console to configure authorization

You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:

[source,yaml]
----
kubectl port-forward keycloak 8080
----

Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.

In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.
Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.

For this example we are interested in the `kafka-authz` realm.
Selecting it will open the `Realm Settings` for the `kafka-authz` realm.
From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.

Under *Groups*, you can view groups to mark users as having some permissions.
Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.

In Keycloak the groups can be stored in an LDAP identity provider.
That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.

Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.
In Keycloak the users can be stored in an LDAP identity provider.

Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.
Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.
Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.

Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.
The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,
and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.
This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.

The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.

Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.

The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.


== Defining Authorization Services for access control

Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.

Resources define _what_ we are protecting from unauthorized access.
Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.
Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.
Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.

For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.

When viewing resources from the Keycloak user interface you will see a list of resource definitions.
These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.
For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':

----
kafka-cluster:cluster-1,Topic:a_*  
---- 

If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':
----
Group:x_* 
----


The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].

*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.
It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.
The list of actions mirrors Kafka permissions and is the same for any deployment.

Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.

You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.

For this example the authorization scopes have already been imported as part of the realm import.

The *Policies* tab has filters that match sets of users.
Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.
Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.

The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.

Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.
For example:

----
Dev Team A can write to topics that start with x_ on any cluster
Dev Team B can read from topics that start with x_ on any cluster
Dev Team B can update consumer group offsets that start with x_ on any cluster
ClusterManager of my-cluster Group has full access to cluster config on my-cluster
ClusterManager of my-cluster Group has full access to consumer groups on my-cluster
ClusterManager of my-cluster Group has full access to topics on my-cluster
----

`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.

`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.

== Targeting permissions using group or role policies

In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.
This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).
Service accounts can have roles assigned like regular users.
They cannot, however, have groups assigned.
As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.
Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.
That is what is used for permissions that start with `ClusterManager`.
Performing cluster management is usually done interactively - in person - using CLI tools.
It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.
In this case, the access token represents the specific user, rather than the client application.


== Authorization in Action Using CLI Clients

A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.
Let's make sure the Authorization rules have been properly imported when the Keycloak was started.

From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.
Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.

With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.

First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.

[source,shell]
----
kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh
----

NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. 

You can attach to the existing pod by running:

[source,shell]
----
kubectl attach -ti kafka-cli
----

To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.

[source,shell]
----
cat > /tmp/team-a-client.properties << EOF
security.protocol=SASL_PLAINTEXT
sasl.mechanism=OAUTHBEARER
sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
EOF
----

The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.

We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.


.Producing messages with authorized access

The `team-a-client` configuration is used to produce messages to topic `my-topic`:

[source,shell]
----
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \
  --producer.config=/tmp/team-a-client.properties
First message
----

A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.

`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.
The topic named `my-topic` matches neither of those rules.

The `team-a-client` configuration is then used to produce messages to topic `a_messages`.

[source,shell]
----
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \
  --producer.config /tmp/team-a-client.properties
First message
Second message
----

The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.

Use CTRL-C to exit the CLI application.

You can see the Kafka container log by running:

[source,shell]
kubectl logs my-cluster-kafka-0 -f

.Consuming messages with authorized access

The `team-a-client` configuration is used to consume messages from topic `a_messages`:

[source,shell,subs=+quotes]
----
bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \
  --from-beginning --consumer.config /tmp/team-a-client.properties
----

An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.
The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:

[source,shell,subs=+quotes]
----
bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \
  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1
----

This time the consumer receives all the messages from the `a_messages` topic.


.Administering Kafka with authorized access

The `team-a-client` configuration is used in administrative operations.

Listing topics returns the `a_messages` topic.

[source,shell]
----
bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list
----    

Listing consumer groups returns the `a_consumer_group_1` consumer group.

[source,shell]
----
bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list
----

Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.

[source,shell]
----
bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \
  --entity-type brokers --describe --entity-default
----


. Using clients with different permissions

As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.

[source,shell]
----
cat > /tmp/team-b-client.properties << EOF
security.protocol=SASL_PLAINTEXT
sasl.mechanism=OAUTHBEARER
sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-b-client" \
  oauth.client.secret="team-b-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
EOF
----

The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.
The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.

The `team-b-client` configuration is used to produce messages to topic `a_messages`:

[source,shell]
----
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \
  --producer.config /tmp/team-b-client.properties
Message 1
----

A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:

[source,shell]
----
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \
  --producer.config /tmp/team-b-client.properties
Message 1
Message 2
Message 3
----

Producing messages to topic `b_messages` is authorized and successful.

We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:

[source,shell]
----
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \
  --producer.config /tmp/team-b-client.properties
Message 1
----

A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:

[source,shell]
----
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \
  --producer.config /tmp/team-a-client.properties
Message 1
----

A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist. 

Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.


.Managing Kafka with an authorized admin

Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.

Helper scripts are used to authenticate to the `keycloak` instance.

The following scripts are downloaded to `/tmp` dir and made executable:

[source,shell]
----
curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh
   chmod +x /tmp/oauth.sh

curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh
   chmod +x /tmp/jwt.sh
----

Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.

   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token
   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)

This will prompt you for a password. Type 'bob-password'.

We can inspect the refresh token:

   /tmp/jwt.sh $REFRESH_TOKEN

By default this is a long-lived refresh token that does not expire.

Now we will create the configuration file for `bob`:

```
cat > /tmp/bob.properties << EOF
security.protocol=SASL_PLAINTEXT
sasl.mechanism=OAUTHBEARER
sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.refresh.token="$REFRESH_TOKEN" \
  oauth.client.id="kafka-cli" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
EOF
```

Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.
Since that is a public client it does not require any secret.
We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).


Let's now try to create the `x_messages` topic:

    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \
      --topic x_messages --create --replication-factor 1 --partitions 1

The operation should succeed (you can ignore the warning about periods and underscores).

We can list the topics:

    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list

If we try the same as `team-a-client` or `team-b-client` we will get different responses.

    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list
    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list

Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.

We can now again try to produce to the topic as `team-a-client`.

```
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \
  --producer.config /tmp/team-a-client.properties
Message 1
Message 2
Message 3
```

This works.

If we try the same as `team-b-client` it should fail.

```
bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \
  --producer.config /tmp/team-b-client.properties
Message 4
Message 5
```

We get an error - `Not authorized to access topics: [x_messages]`.

But `team-b-client` should be able to consume messages from the `x_messages` topic:

    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \
      --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b

Whereas `team-a-client` does not have permission to read, even though they can write:

    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \
      --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a

We get a `Not authorized to access group: x_consumer_group_a` error.

What if we try to use a consumer group name that starts with 'a_'?

    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \
      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a

We now get a different error: `Not authorized to access topics: [x_messages]`

It just won't work - `Dev Team A` has no `Read` access on topics that start with 'x_'.

User `bob` should have no problem reading from or writing to any topic:

    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \
      --from-beginning --consumer.config /tmp/bob.properties
